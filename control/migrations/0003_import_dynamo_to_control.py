# Generated by Django 3.0.3 on 2020-04-10 18:16

import logging
import os
from datetime import datetime

import boto3
from django.db import migrations, models, transaction

from laika.utils.dates import YYYY_MM_DD, dynamo_timestamp_to_datetime
from laika.utils.dictionaries import exclude_dict_keys
from laika.utils.strings import camel_to_snake, remove_prefix

logger = logging.getLogger('control_migration')

ENVIRONMENT = os.getenv('ENVIRONMENT')
LEGACY_AWS_ACCESS_KEY = os.getenv('LEGACY_AWS_ACCESS_KEY')
LEGACY_AWS_SECRET_ACCESS_KEY = os.getenv('LEGACY_AWS_SECRET_ACCESS_KEY')


def store_tags(apps, tags, control):
    ControlTag = apps.get_model('control', 'ControlTag')
    Tag = apps.get_model('tag', 'Tag')
    safer_tags = tags or []

    for tag in safer_tags:
        tag_name = [val for (key, val) in tag.items()][0]
        t, _ = Tag.objects.get_or_create(
            name=tag_name, organization_id=control.organization_id
        )
        ControlTag.objects.create(tag=t, control=control)


def get_or_create_user(apps, user_type, email, organization_id):
    if email == 'Unnasigned':
        return

    User = apps.get_model('user', 'User')
    user, _ = User.objects.get_or_create(
        email=email,
        organization_id=organization_id,
        defaults={
            'role': '',
            'last_name': '',
            'first_name': '',
            'is_active': False,
            'username': '',
        },
    )

    return user


def get_controls_from_dynamo():
    env = ENVIRONMENT

    if ENVIRONMENT == 'prod':
        env = 'production'
    elif ENVIRONMENT == 'local':
        # In case we are in local we would need to get it from dev
        env = 'dev'

    client = boto3.client(
        'dynamodb',
        region_name='us-east-1',
        aws_access_key_id=LEGACY_AWS_ACCESS_KEY,
        aws_secret_access_key=LEGACY_AWS_SECRET_ACCESS_KEY,
    )

    tables_response = client.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-ControlTable' in t]
    controls = []

    if name:
        control_response = client.scan(TableName=name[0])
        controls = control_response.get('Items', [])

        while 'LastEvaluatedKey' in control_response:
            control_response = client.scan(
                TableName=name[0],
                ExclusiveStartKey=control_response['LastEvaluatedKey'],
            )
            controls.extend(control_response.get('Items', []))

    return controls


def _get_display_id(Control, organization_id):
    # Get the maximum display_id value from the database
    last_id = Control.objects.filter(organization_id=organization_id).aggregate(
        largest=models.Max('display_id')
    )['largest']

    if last_id is not None:
        return last_id + 1

    return 1


def map_dynamo_control(apps, control):
    Control = apps.get_model('control', 'Control')

    c = {}
    for key in control:
        value = list(control[key].values())[0]
        pgKey = camel_to_snake(key)

        if key == 'createdAt' or key == 'updatedAt':
            date_time = dynamo_timestamp_to_datetime(int(value))
            value = datetime.strftime(date_time, YYYY_MM_DD)

        if key == 'implementationNotes':
            notes_info = {
                camel_to_snake(key): list(val.values())[0]
                for (key, val) in value.items()
            }

            if notes_info and notes_info.get('type') != 'EMPTY':
                value = notes_info.get('data')
            else:
                value = None

        if key == 'displayId':
            organization_id = list(control['organizationId'].values())[0]
            value = _get_display_id(Control, organization_id)

        if key == 'id':
            value = remove_prefix(value, 'c-')

        c[pgKey] = value

    return c


def migrate_controls(apps, schema_editor):
    Control = apps.get_model('control', 'Control')
    Organization = apps.get_model('organization', 'Organization')

    controls = get_controls_from_dynamo()

    control = {}
    for c in controls:
        with transaction.atomic():
            control = map_dynamo_control(apps, c)
            organization_exists = Organization.objects.filter(
                id=control.get('organization_id')
            ).exists()

            if not organization_exists:
                logger.warn(f'Skipping adding control: {c.get("id")}')
            else:
                # owner, approver, administrator
                organization_id = control.get('organization_id')
                control['administrator'] = get_or_create_user(
                    apps, 'administrator', control.get('administrator'), organization_id
                )
                control['approver'] = get_or_create_user(
                    apps, 'approver', control.get('approver'), organization_id
                )
                control['owner'] = get_or_create_user(
                    apps, 'owner', control.get('owner'), organization_id
                )

                control_data = exclude_dict_keys(
                    control, ['tags', 'associated_tasks', 'associated_policies']
                )
                stored_control, _ = Control.objects.update_or_create(
                    name=control_data.get('name'),
                    organization_id=control_data.get('organization_id'),
                    defaults={**control_data, 'implementation_notes': ''},
                )

                # Tags
                tags = control.get('tags')
                store_tags(apps, tags, stored_control)

            control = {}


class Migration(migrations.Migration):
    dependencies = [
        ('user', '0012_updating_username_field'),
        ('control', '0004_update_name_type'),
    ]

    operations = [migrations.RunPython(migrate_controls)]

# Generated by Django 3.0.2 on 2020-02-17 18:13
import os
import warnings

import boto3

from laika.aws.secrets import REGION_NAME
from laika.utils.strings import camel_to_snake, remove_prefix

ORGANIZATION_ID = ":organizationId"
ORGANIZATION_FILTER_EXP = 'organizationId = :organizationId'
TASK_ID_PREFIX = 't-'
SUBTASK_ID_PREFIX = 's-'


ENVIRONMENT = os.getenv('ENVIRONMENT')
LEGACY_AWS_ACCESS_KEY = os.getenv('LEGACY_AWS_ACCESS_KEY')
LEGACY_AWS_SECRET_ACCESS_KEY = os.getenv('LEGACY_AWS_SECRET_ACCESS_KEY')

DEPRECATED_MESSAGE = (
    'deprecated since legacy documents from dynamo are not being used anymore'
)

session = boto3.session.Session()
dynamo = session.client(
    'dynamodb',
    region_name=REGION_NAME,
    aws_access_key_id=LEGACY_AWS_ACCESS_KEY,
    aws_secret_access_key=LEGACY_AWS_SECRET_ACCESS_KEY,
)

env = ENVIRONMENT

if ENVIRONMENT == 'prod':
    env = 'production'
elif ENVIRONMENT == 'local':
    # In case we are in local we would need to get it from dev
    env = 'dev'


def deprecate_method():
    warnings.simplefilter('default')
    warnings.warn(DEPRECATED_MESSAGE, DeprecationWarning)


def get_program(organization_id, program_id):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-ProgramTable' in t]
    program_response = []
    query = {
        'TableName': name[0],
        'KeyConditionExpression': (
            'id = :programId and organizationId = :organizationId'
        ),
        'ExpressionAttributeValues': {
            ORGANIZATION_ID: {"S": str(organization_id)},
            ":programId": {"S": str(program_id)},
        },
    }
    response = dynamo.query(**query)
    program_response.extend(response['Items'])
    program = len(program_response) > 0 and program_response[0]

    for key in program:
        value = list(program[key].values())[0]
        program[key] = value

    return program or {}


def get_tasks_by_program(organization_id, program_id):
    name = get_table_name('TaskTable')
    query = {
        'TableName': name[0],
        'KeyConditionExpression': ORGANIZATION_FILTER_EXP,
        'FilterExpression': 'programId = :program_id',
        'ExpressionAttributeValues': {
            ORGANIZATION_ID: {"S": str(organization_id)},
            ":program_id": {"S": str(program_id)},
        },
    }

    tasks_response = query_all(query)

    tasks = []
    for task in tasks_response:
        t = {}
        for key in task:
            value = list(task[key].values())[0]
            if key == 'id':
                value = remove_prefix(value, 't-')
            if key == 'associatedControls':
                value = [list(v.values())[0] for v in value]
            pg_key = camel_to_snake(key)
            t[pg_key] = value

        tasks.append(t)
    return tasks or []


def query_all(query):
    items_response = []
    response = dynamo.query(**query)
    items_response.extend(response['Items'])

    while 'LastEvaluatedKey' in response:
        query['ExclusiveStartKey'] = response['LastEvaluatedKey']
        response = dynamo.query(**query)
        items_response.extend(response['Items'])

    return items_response


def get_subtasks_in_ids(organization_id, subtask_ids):
    name = get_table_name('TaskTable')
    batch_keys = {
        name[0]: {
            'Keys': [
                {
                    'id': {'S': f'{SUBTASK_ID_PREFIX}{subtask_id}'},
                    'organizationId': {'S': organization_id},
                }
                for subtask_id in subtask_ids
            ]
        }
    }

    response = dynamo.batch_get_item(RequestItems=batch_keys)
    subtasks_response = response['Responses'][name[0]]

    subtasks = []
    for subtask in subtasks_response:
        t = {}
        for key in subtask:
            value = list(subtask[key].values())[0]
            if key == 'id':
                value = remove_prefix(value, SUBTASK_ID_PREFIX)
            if key == 'taskId':
                value = remove_prefix(value, TASK_ID_PREFIX)
            pg_key = camel_to_snake(key)
            t[pg_key] = value

        subtasks.append(t)
    return subtasks


def get_policies(organization_id):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-PolicyTable' in t]
    policy_response = []
    query = {
        'TableName': name[0],
        'KeyConditionExpression': ORGANIZATION_FILTER_EXP,
        'ExpressionAttributeValues': {ORGANIZATION_ID: {"S": str(organization_id)}},
    }
    response = dynamo.query(**query)
    policy_response.extend(response['Items'])

    while 'LastEvaluatedKey' in response:
        query['ExclusiveStartKey'] = response['LastEvaluatedKey']
        response = dynamo.query(**query)
        policy_response.extend(response['Items'])

    policy_objects = []
    for policy in policy_response:
        p = {}
        for key in policy:
            value = list(policy[key].values())[0]
            pg_key = camel_to_snake(key)
            p[pg_key] = value
        policy_objects.append(p)

    return policy_objects


def get_programs(organization_id):
    name = get_table_name('ProgramTable')
    query = {
        'TableName': name[0],
        'KeyConditionExpression': ORGANIZATION_FILTER_EXP,
        'ExpressionAttributeValues': {ORGANIZATION_ID: {"S": str(organization_id)}},
    }

    program_response = query_all(query)

    program_objects = []
    for program in program_response:
        p = {}
        for key in program:
            value = list(program[key].values())[0]
            pg_key = camel_to_snake(key)
            p[pg_key] = value
        program_objects.append(p)

    return program_objects


def get_table_name(table_name):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-{table_name}' in t]
    return name


def map_evidence(evidence):
    for key in evidence:
        evidence_array = list(evidence.get(key).values())[0]
        evidence[key] = [list(e.values())[0] for e in evidence_array]

    return evidence


def get_tasks_by_id(organization, task_id):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-TaskTable' in t]
    query = {
        'TableName': name[0],
        'KeyConditionExpression': (
            'organizationId = :organizationId             and id = :task_id'
        ),
        'ExpressionAttributeValues': {
            ORGANIZATION_ID: {"S": str(organization.id)},
            ":task_id": {"S": str(task_id)},
        },
    }
    response = dynamo.query(**query)
    items = response.get('Items', [])
    task_response = items[0] if len(items) else {}

    task = {}
    for key in task_response:
        value = list(task_response[key].values())[0]
        if key == 'id':
            value = remove_prefix(value, 't-')
        pg_key = camel_to_snake(key)
        if key == 'evidences':
            value = map_evidence(value)

        task[pg_key] = value

    return task


# TODO: this method should be removed when legacy documents
# are not stored in dynamo db anymore. Meanwhile it will be deprecated.
def get_document_details(organization, document_id):
    deprecate_method()
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    table_name = [t for t in table_names if f'{env}-DocumentTable' in t]

    query = {
        'TableName': table_name[0],
        'KeyConditionExpression': 'id = :id AND organizationId = :organizationId',
        'ExpressionAttributeValues': {
            ORGANIZATION_ID: {'S': str(organization.id)},
            ':id': {'S': f'd-{document_id}'},
        },
    }
    response = dynamo.query(**query)
    items = response.get('Items', [])
    item = items[0] if len(items) else {}
    document_name = item.get('name', {}).get('S')
    document_description = item.get('description', {}).get('S')
    return document_name, document_description


def get_document(organization_id, document_id):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-DocumentTable' in t]

    query = {
        'TableName': name[0],
        'KeyConditionExpression': (
            'id = :document_id and organizationId = :organizationId'
        ),
        'ExpressionAttributeValues': {
            ORGANIZATION_ID: {"S": str(organization_id)},
            ":document_id": {"S": str(document_id)},
        },
    }
    response = dynamo.query(**query)
    item = response['Items'][0]
    data = item['text']['M']['data']
    document_text = data['S'] if 'NULL' not in data else ''
    return document_text


def get_tasks_for_org(organization):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-TaskTable' in t]
    tasks_response = []
    query = {
        'TableName': name[0],
        'KeyConditionExpression': ORGANIZATION_FILTER_EXP,
        'ExpressionAttributeValues': {ORGANIZATION_ID: {"S": str(organization.id)}},
    }
    response = dynamo.query(**query)
    tasks_response.extend(response['Items'])

    while 'LastEvaluatedKey' in response:
        query['ExclusiveStartKey'] = response['LastEvaluatedKey']
        response = dynamo.query(**query)
        tasks_response.extend(response['Items'])

    tasks = []
    for task in tasks_response:
        t = {}
        for key in task:
            value = list(task[key].values())[0]
            if key == 'id':
                value = remove_prefix(value, 't-')
            pg_key = camel_to_snake(key)
            if key == 'evidences':
                value = map_evidence(value)

            t[pg_key] = value
        tasks.append(t)

    return tasks


def get_table_count_info(organization, table_name, filter_expression={}):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-{table_name}Table' in t]
    query = {
        'TableName': name[0],
        'KeyConditionExpression': ORGANIZATION_FILTER_EXP,
        **filter_expression,
        'ExpressionAttributeValues': {ORGANIZATION_ID: {"S": str(organization.id)}},
    }
    response = dynamo.query(**query)
    table_response = []
    table_response.extend(response['Items'])

    while 'LastEvaluatedKey' in response:
        query['ExclusiveStartKey'] = response['LastEvaluatedKey']
        response = dynamo.query(**query)
        table_response.extend(response['Items'])

    table_display_ids = []
    for r in table_response:
        for key in r:
            value = list(r[key].values())[0]
            if key == 'displayId':
                table_display_ids.append(value)

    return {'count': len(table_response), 'display_ids': table_display_ids}


def set_organization_counter(organization, counter_name, current_value):
    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-CounterTable' in t]
    query = {
        'TableName': name[0],
        'Key': {
            'organizationId': {'S': str(organization.id)},
            'counterName': {'S': str(counter_name)},
        },
        'UpdateExpression': 'SET currentValue = :current_value',
        'ExpressionAttributeValues': {":current_value": {'S': str(current_value)}},
        'ReturnValues': 'UPDATED_NEW',
    }
    return dynamo.update_item(**query)


def update_document_name(organization, document_id, new_name):
    deprecate_method()

    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-DocumentTable' in t]
    query = {
        'TableName': name[0],
        'Key': {
            'organizationId': {'S': str(organization.id)},
            'id': {'S': f'd-{str(document_id)}'},
        },
        'UpdateExpression': 'set #new_name = :new_name',
        'ExpressionAttributeValues': {":new_name": {'S': new_name}},
        'ExpressionAttributeNames': {"#new_name": "name"},
        'ReturnValues': 'UPDATED_NEW',
    }
    response = dynamo.update_item(**query)
    return response


def get_evidences(organization_id):
    deprecate_method()

    tables_response = dynamo.list_tables()
    table_names = tables_response.get('TableNames')
    document_table = next(
        (name for name in table_names if f'{env}-DocumentTable' in name), None
    )

    if not document_table:
        return []

    query = {
        'TableName': document_table,
        'KeyConditionExpression': ORGANIZATION_FILTER_EXP,
        'ExpressionAttributeValues': {ORGANIZATION_ID: {"S": organization_id}},
    }
    response = dynamo.query(**query)
    return [flatten_document(e) for e in response['Items']]


# TODO:TR-176 should delete this method.
def flatten_document(document):
    deprecate_method()

    result = {}
    for key in document:
        new_key = camel_to_snake(key)
        value = list(document[key].values())[0]
        nested_type = isinstance(value, dict)
        result[new_key] = value if not nested_type else flatten_document(value)
    return result

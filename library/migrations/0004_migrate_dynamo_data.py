# Generated by Django 3.0.3 on 2020-07-06 20:25

import logging
import os
from datetime import datetime

import boto3
from django.db import migrations, models, transaction

from laika.utils.dates import YYYY_MM_DD, dynamo_timestamp_to_datetime
from laika.utils.dictionaries import exclude_dict_keys
from laika.utils.strings import camel_to_snake

logger = logging.getLogger('control_migration')

ENVIRONMENT = os.getenv('ENVIRONMENT')
LEGACY_AWS_ACCESS_KEY = os.getenv('LEGACY_AWS_ACCESS_KEY')
LEGACY_AWS_SECRET_ACCESS_KEY = os.getenv('LEGACY_AWS_SECRET_ACCESS_KEY')


def get_entries_from_dynamo():
    env = ENVIRONMENT

    if ENVIRONMENT == 'prod':
        env = 'production'
    elif ENVIRONMENT == 'local':
        # In case we are in local we would need to get it from dev
        env = 'dev'

    client = boto3.client(
        'dynamodb',
        region_name='us-east-1',
        aws_access_key_id=LEGACY_AWS_ACCESS_KEY,
        aws_secret_access_key=LEGACY_AWS_SECRET_ACCESS_KEY,
    )

    tables_response = client.list_tables()
    table_names = tables_response.get('TableNames')
    name = [t for t in table_names if f'{env}-LibraryTable' in t]
    entries = []

    if name:
        library_response = client.scan(TableName=name[0])
        entries = library_response.get('Items', [])

        while 'LastEvaluatedKey' in library_response:
            library_response = client.scan(
                TableName=name[0],
                ExclusiveStartKey=library_response['LastEvaluatedKey'],
            )
            entries.extend(library_response.get('Items', []))

    return entries


def _get_display_id(LibraryEntry, organization_id):
    # Get the maximum display_id value from the database
    last_id = LibraryEntry.objects.filter(organization_id=organization_id).aggregate(
        largest=models.Max('display_id')
    )['largest']

    if last_id is not None:
        return last_id + 1

    return 1


def store_questions(Question, entry, questions):
    question_objs = []
    for i, q in enumerate(questions):
        default = i == 0
        question_objs.append(Question(text=q, default=default, library_entry=entry))

    Question.objects.bulk_create(objs=question_objs)


def map_dynamo_entry(apps, entry):
    LibraryEntry = apps.get_model('library', 'LibraryEntry')

    e = {}
    for key in entry:
        value = list(entry[key].values())[0]
        pgKey = camel_to_snake(key)

        if value == 'counterEntry':
            return

        if key == 'createdAt' or key == 'updatedAt':
            date_time = dynamo_timestamp_to_datetime(int(value))
            value = datetime.strftime(date_time, YYYY_MM_DD)

        if key == 'answer':
            value = {
                camel_to_snake(key): list(val.values())[0]
                for (key, val) in value.items()
            }

        if key == 'category' and value == 'Imported questions':
            value = 'Other'

        if key == 'questions':
            value = [v['S'].strip() for v in value]

        if key == 'displayId':
            organization_id = list(entry['organizationId'].values())[0]
            value = _get_display_id(LibraryEntry, organization_id)

        e[pgKey] = value

    return e


def migrate_library_entries(apps, schema_editor):
    LibraryEntry = apps.get_model('library', 'LibraryEntry')
    Organization = apps.get_model('organization', 'Organization')
    User = apps.get_model('user', 'User')
    Question = apps.get_model('library', 'Question')

    entries = get_entries_from_dynamo()

    entry = {}

    for e in entries:
        try:
            with transaction.atomic():
                entry = map_dynamo_entry(apps, e)

                if entry:
                    organization_id = entry.get('organization_id')

                    organization_qs = Organization.objects.filter(id=organization_id)

                    if not organization_qs.exists():
                        logger.warn(
                            'Organization not found.'
                            f' Skipping adding library entry: {e.get("id")}'
                        )
                    else:
                        organization = organization_qs.first()

                        entry['updated_by'] = User.objects.filter(
                            organization=organization, email=entry.get('updated_by')
                        ).first()

                        answer = entry.get('answer', {})
                        entry['answer_text'] = answer.get('text', '')
                        entry['answer_choice'] = answer.get('choice', '')

                        questions = entry.get('questions', [])

                        duplicated = Question.objects.filter(
                            text__in=questions, library_entry__organization=organization
                        )
                        entry_id = e.get("id")
                        if duplicated.exists():
                            logger.warn(
                                f'Duplicated questions found: {duplicated}'
                                f' for organization {organization.id}.'
                                f' Skipping adding library entry: {entry_id}.'
                            )
                        else:
                            stored_entry = LibraryEntry.objects.create(
                                **exclude_dict_keys(
                                    entry, ['questions', 'id', 'answer']
                                )
                            )

                            store_questions(Question, stored_entry, questions)
        except Exception as err:
            logger.warn(
                f'Error procesing libray entry: {e.get("id")}'
                f' for organization {e.get("organizationId")}',
                err,
            )
            continue


class Migration(migrations.Migration):
    dependencies = [
        ('library', '0003_update_choice_field'),
    ]

    operations = [migrations.RunPython(migrate_library_entries)]
